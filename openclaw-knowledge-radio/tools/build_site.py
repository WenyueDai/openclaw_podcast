#!/usr/bin/env python3
from __future__ import annotations
import json
import os
import random
from pathlib import Path
from datetime import datetime, timezone
import html

# Derive paths relative to this file so the script works on any machine.
# Override any of these with environment variables if needed.
_PACKAGE_DIR = Path(__file__).resolve().parent.parent   # …/openclaw-knowledge-radio/
_REPO_ROOT = _PACKAGE_DIR.parent                        # …/openclaw-knowledge-radio (git root)

BASE_OUTPUT = Path(os.environ.get("PODCAST_OUTPUT", str(_PACKAGE_DIR / "output")))
SITE_DIR    = Path(os.environ.get("SITE_DIR",       str(_REPO_ROOT / "docs")))
AUDIO_DIR   = SITE_DIR / "audio"
RELEASE_INDEX = Path(os.environ.get("RELEASE_INDEX", str(_PACKAGE_DIR / "state" / "release_index.json")))

PODCAST_TITLE = os.environ.get("PODCAST_TITLE", "Daily Podcast")
PODCAST_AUTHOR = os.environ.get("PODCAST_AUTHOR", "Eva Dai")
PODCAST_EMAIL = os.environ.get("PODCAST_EMAIL", "daiwenyueva@gmail.com")
PODCAST_SUMMARY = os.environ.get("PODCAST_SUMMARY", "Daily autogenerated science podcast")
PODCAST_COVER_URL = os.environ.get("PODCAST_COVER_URL", "https://wenyuedai.github.io/openclaw_podcast/cover.svg")


def _load_release_index() -> dict:
    if RELEASE_INDEX.exists():
        try:
            return json.loads(RELEASE_INDEX.read_text(encoding="utf-8"))
        except Exception:
            return {}
    return {}


def _first_sentence(text: str) -> str:
    """Return only the first sentence of text."""
    import re
    m = re.search(r'[.!?](?:\s|$)', text)
    return text[:m.start() + 1].strip() if m else text


def _extract_highlights(script_path: Path | None, max_points: int = 5) -> list[str]:
    if not script_path or not script_path.exists():
        return []
    points: list[str] = []
    try:
        for raw in script_path.read_text(encoding="utf-8", errors="ignore").splitlines():
            line = raw.strip().strip("-• ")
            if not line:
                continue
            low = line.lower()
            if low.startswith("references") or low.startswith("["):
                continue
            if "http://" in low or "https://" in low:
                continue
            if len(line) < 45:
                continue
            points.append(_first_sentence(line))
            if len(points) >= max_points:
                break
    except Exception:
        return []
    return points


def discover_episodes():
    episodes = []
    release_idx = _load_release_index()
    if not BASE_OUTPUT.exists():
        return episodes
    for d in sorted(BASE_OUTPUT.iterdir()):
        if not d.is_dir():
            continue
        date = d.name
        mp3 = d / f"podcast_{date}.mp3"
        script = d / f"podcast_script_{date}_llm.txt"
        if not script.exists():
            script = d / f"podcast_script_{date}_llm_clean.txt"
        if not mp3.exists():
            continue
        script_path = script if script.exists() else None
        episodes.append({
            "date": date,
            "title": f"Daily Podcast {date}",
            "mp3_src": mp3,
            "mp3_name": mp3.name,
            "mp3_size": mp3.stat().st_size,
            "audio_url": release_idx.get(date, f"audio/{mp3.name}"),
            "script": script_path,
            "script_name": script.name if script_path else None,
            "highlights": _extract_highlights(script_path, max_points=3),
        })
    episodes.sort(key=lambda x: x["date"], reverse=True)
    return episodes


def generate_cover_svg(seed_text: str):
    rnd = random.Random(seed_text)
    w, h = 1400, 1400
    bg1 = f"hsl({rnd.randint(0,359)},70%,55%)"
    bg2 = f"hsl({rnd.randint(0,359)},75%,35%)"
    shapes = []
    for _ in range(18):
        cx = rnd.randint(0, w)
        cy = rnd.randint(0, h)
        r = rnd.randint(60, 260)
        color = f"hsla({rnd.randint(0,359)},85%,{rnd.randint(35,70)}%,0.45)"
        shapes.append(f"<circle cx='{cx}' cy='{cy}' r='{r}' fill='{color}'/>")

    return f"""<svg xmlns='http://www.w3.org/2000/svg' width='{w}' height='{h}' viewBox='0 0 {w} {h}'>
<defs>
  <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
    <stop offset='0%' stop-color='{bg1}'/>
    <stop offset='100%' stop-color='{bg2}'/>
  </linearGradient>
</defs>
<rect width='100%' height='100%' fill='url(#g)'/>
{''.join(shapes)}
<rect x='80' y='980' width='1240' height='280' rx='32' fill='rgba(0,0,0,0.35)'/>
<text x='120' y='1090' fill='white' font-size='92' font-family='Arial, Helvetica, sans-serif' font-weight='700'>{html.escape(PODCAST_TITLE)}</text>
<text x='120' y='1170' fill='white' font-size='46' font-family='Arial, Helvetica, sans-serif'>Auto-generated Daily Episode</text>
</svg>"""


def render_index(episodes):
    cards = []
    for ep in episodes:
        s_link = f'<a href="{html.escape(ep["script_name"])}">full script</a>' if ep["script_name"] else ""
        hl = ep.get("highlights") or []
        hl_html = "".join([f"<li>{html.escape(h)}</li>" for h in hl]) if hl else "<li>No highlights extracted yet.</li>"
        cards.append(
            f"""
<section class='card'>
  <h2>{html.escape(ep['title'])}</h2>
  <p class='meta'>Published: {html.escape(ep['date'])}</p>
  <audio controls src="{html.escape(ep['audio_url'])}"></audio>
  <p><a href="{html.escape(ep['audio_url'])}">download mp3</a> {s_link}</p>
  <div class='abstract'>
    <h3>Highlights</h3>
    <ul>{hl_html}</ul>
  </div>
</section>
"""
        )
    body = "\n".join(cards) if cards else "<section class='card'><p>No episodes yet.</p></section>"
    return f"""<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1'>
<title>{html.escape(PODCAST_TITLE)}</title>
<style>
:root {{ --bg:#eef7ef; --bg2:#f7f4e9; --card:#fffdf6; --text:#2d3d33; --muted:#6d7f71; --accent:#4f8f6a; --line:#dbe7d9; }}
* {{ box-sizing:border-box; }}
body {{ margin:0; font-family:"Hiragino Sans","Noto Sans JP",Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(160deg,var(--bg),var(--bg2)); color:var(--text); }}
main {{ max-width:900px; margin:0 auto; padding:28px 16px 40px; }}
h1 {{ margin:0 0 8px; letter-spacing:.3px; }}
.sub {{ color:var(--muted); margin-bottom:18px; }}
.card {{ background:var(--card); border:1px solid var(--line); border-radius:18px; padding:16px; margin:14px 0; box-shadow:0 10px 22px rgba(79,143,106,.12); }}
h2 {{ margin:0 0 4px; font-size:1.15rem; }}
.meta {{ color:var(--muted); margin:0 0 10px; font-size:.92rem; }}
a {{ color:var(--accent); text-decoration:none; }}
a:hover {{ text-decoration:underline; }}
audio {{ width:100%; margin:6px 0 8px; }}
.abstract h3 {{ margin:10px 0 6px; font-size:1rem; color:#4c6f5a; }}
.abstract ul {{ margin:0; padding-left:20px; }}
.abstract li {{ margin:6px 0; line-height:1.45; }}
</style>
</head>
<body>
<main>
  <h1>{html.escape(PODCAST_TITLE)}</h1>
  <p class='sub'>{html.escape(PODCAST_SUMMARY)}.</p>
  <p class='sub'>Playback speed:
    <button onclick="setRate(1)">1x</button>
    <button onclick="setRate(1.2)">1.2x</button>
    <button onclick="setRate(1.5)">1.5x</button>
    <button onclick="setRate(2)">2x</button>
  </p>
  {body}
</main>
<script>
function setRate(v) {{
  document.querySelectorAll('audio').forEach(a => {{ a.playbackRate = v; }});
}}
</script>
</body>
</html>
"""


def render_feed(episodes, site_url: str):
    now = datetime.now(timezone.utc).strftime("%a, %d %b %Y %H:%M:%S GMT")
    items = []
    for ep in episodes[:60]:
        pub = datetime.strptime(ep["date"], "%Y-%m-%d").strftime("%a, %d %b %Y 08:00:00 GMT")
        mp3_url = ep.get("audio_url") or f"{site_url}/audio/{ep['mp3_name']}"
        if mp3_url.startswith("audio/"):
            mp3_url = f"{site_url}/{mp3_url}"
        mp3_len = ep.get("mp3_size", 0)
        highlights = ep.get("highlights") or []
        abstract = " | ".join(highlights[:3]) if highlights else PODCAST_SUMMARY
        items.append(f"""
    <item>
      <title>{html.escape(ep['title'])}</title>
      <guid isPermaLink="false">{mp3_url}</guid>
      <pubDate>{pub}</pubDate>
      <enclosure url=\"{mp3_url}\" length=\"{mp3_len}\" type=\"audio/mpeg\" />
      <description>{html.escape(abstract)}</description>
      <itunes:author>{html.escape(PODCAST_AUTHOR)}</itunes:author>
      <itunes:summary>{html.escape(abstract)}</itunes:summary>
      <itunes:explicit>false</itunes:explicit>
      <itunes:image href=\"{PODCAST_COVER_URL}\" />
    </item>""")
    return f"""<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0'
     xmlns:itunes='http://www.itunes.com/dtds/podcast-1.0.dtd'
     xmlns:atom='http://www.w3.org/2005/Atom'>
  <channel>
    <title>{html.escape(PODCAST_TITLE)}</title>
    <link>{site_url}</link>
    <atom:link href="{site_url}/feed.xml" rel="self" type="application/rss+xml" />
    <description>{html.escape(PODCAST_SUMMARY)}</description>
    <language>en</language>
    <lastBuildDate>{now}</lastBuildDate>
    <itunes:author>{html.escape(PODCAST_AUTHOR)}</itunes:author>
    <itunes:summary>{html.escape(PODCAST_SUMMARY)}</itunes:summary>
    <itunes:owner>
      <itunes:name>{html.escape(PODCAST_AUTHOR)}</itunes:name>
      <itunes:email>{html.escape(PODCAST_EMAIL)}</itunes:email>
    </itunes:owner>
    <itunes:image href="{PODCAST_COVER_URL}" />
    <itunes:explicit>false</itunes:explicit>
    {''.join(items)}
  </channel>
</rss>
"""


def main():
    site_url = "https://wenyuedai.github.io/openclaw_podcast"
    SITE_DIR.mkdir(parents=True, exist_ok=True)
    AUDIO_DIR.mkdir(parents=True, exist_ok=True)

    episodes = discover_episodes()

    # Web page shows only the 3 most recent episodes; RSS feed keeps all
    WEB_EPISODES = 3
    web_episodes = episodes[:WEB_EPISODES]

    # generate a random-ish cover each day (seeded by latest episode date)
    cover_seed = episodes[0]["date"] if episodes else datetime.now(timezone.utc).strftime("%Y-%m-%d")
    (SITE_DIR / "cover.svg").write_text(generate_cover_svg(cover_seed), encoding="utf-8")

    # Copy script txt files for web episodes only; remove stale ones
    web_script_names = {ep["script_name"] for ep in web_episodes if ep["script_name"]}
    for ep in web_episodes:
        if ep["script"]:
            (SITE_DIR / ep["script_name"]).write_text(
                ep["script"].read_text(encoding="utf-8"), encoding="utf-8"
            )
    for f in SITE_DIR.glob("podcast_script_*.txt"):
        if f.name not in web_script_names:
            f.unlink()

    # remove stale local audio files (only matters if audio is stored locally)
    keep_audio = set()
    for ep in web_episodes:
        audio_url = ep.get("audio_url", "")
        is_remote = audio_url.startswith("http://") or audio_url.startswith("https://")
        if not is_remote:
            (AUDIO_DIR / ep["mp3_name"]).write_bytes(ep["mp3_src"].read_bytes())
            keep_audio.add(ep["mp3_name"])
    for f in AUDIO_DIR.glob("*.mp3"):
        if f.name not in keep_audio:
            f.unlink()

    (SITE_DIR / "episodes.json").write_text(json.dumps([
        {"date": e["date"], "title": e["title"], "audio": e.get("audio_url", f"audio/{e['mp3_name']}"), "script": e["script_name"]}
        for e in web_episodes
    ], indent=2), encoding="utf-8")

    (SITE_DIR / "index.html").write_text(render_index(web_episodes), encoding="utf-8")
    (SITE_DIR / "feed.xml").write_text(render_feed(episodes, site_url), encoding="utf-8")
    print(f"Built site with {len(web_episodes)} episode(s) shown (of {len(episodes)} total): {SITE_DIR}")


if __name__ == "__main__":
    main()
